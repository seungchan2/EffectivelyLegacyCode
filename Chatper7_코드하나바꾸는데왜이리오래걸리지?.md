<img width="502" alt="스크린샷 2024-09-02 오후 2 30 22" src="https://github.com/user-attachments/assets/86e00fff-9a35-4d14-a6fa-a8cc5d122bc4"># Chapter7.코드 하나 바꾸는 데 왜 이리 오래 걸리지?

 ## 코드 이해하기
 - 프로젝트에 포함된 코드의 양이 늘어나면 점차 코드 전체를 이해하는데 시간이 오래 걸린다.
 - 레거시 시스템의 경우 무엇을 해야 할지 이해하는데도 오랜 시간이 걸린다.

## 지연 시간
- 변경을 수행한 시점과 그 변경에 대한 실질적인 피드백을 받을 때까지의 시간을 말한다.
- 코드 변경을 수행하고, 빌드를 시작하며, 결과를 확인한다.
- 시스템 내의 모든 클래스 및 모듈을 다른 클래스 및 모듈과는 독립적으로 테스트 하네스에서 컴파일할 수 있게 해야 한다.
- 잘못된 점을 발견하고 수정하는 데 드는 시간이 줄어든다는 점이 중요하다.

 ## 의존 관계 제거
 1. 클래스의 인스턴스화:
- 필요한 클래스를 테스트 환경에서 인스턴스화(객체 생성)하려고 한다. 복잡한 경우에는 테스트 환경으로 클래스를 가져올 수 없을 때 사용 가능한 여러 가지 기법을 사용해야 한다.
	
2. 의존성 제거
- 클래스의 객체를 테스트 환경에서 생성할 수 있다면, 이제 개별 메서드를 테스트하기 위해 추가적인 의존성을 끊어야 한다.
- 특히 테스트하려는 메서드가 외부 리소스(예: 데이터베이스, 하드웨어, 통신 인프라 등)에 접근하는 경우, 해당 의존성으로 인해 테스트가 어려워질 수 있다.

3. 빠른 피드백
- 클래스의 변경을 테스트할 수 있다면, 일반적으로 매우 빠른 “편집-컴파일-링크-테스트” 사이클을 활용할 수 있다.
- 대부분의 경우, 메서드 자체의 실행 비용은 비교적 낮지만, 메서드가 호출하는 외부 리소스의 비용이 높은 경우에는 문제가 발생할 수 있다.
	
4. 의존성 제거의 전략
- 많은 클래스를 다루는 복잡한 코드에서 작업할 때, 모든 관련된 클래스의 의존성을 끊어야 하는 것은 아니다. 특정 지점에서 테스트 작성을 더 쉽게 할 수 있는 `핀치 포인트(Pinch Point)`를 사용한다.

 ## 빌드 의존 관계
1. 의존성 파악:
- 빌드를 더 빠르게 하려면, 먼저 어떤 의존성들이 빌드를 방해하는지 파악해야 한다.

2. 인터페이스 추출:
- 클래스 클러스터에서 외부에서 사용되는 클래스들은 인터페이스를 추출하여, 이를 통해 의존성을 줄일 수 있다. IDE를 활용하여 인터페이스를 쉽게 추출하고, 코드 베이스에서 클래스 대신 인터페이스를 참조하도록 변경할 수 있다.
- C++에서는 Extract Implementer와 같은 방법을 사용하여 특정 클래스의 구현을 분리하고, 그 클래스의 인스턴스를 생성하는 부분을 변경하여 의존성을 줄인다.

3. 빌드 구조 변경:
- 의존성을 줄인 클래스 클러스터를 새로운 패키지나 라이브러리로 이동시켜 프로젝트의 물리적 구조를 변경함으로써 빌드를 더 쉽게 만들 수 있다. 이는 빌드 시스템을 더 복잡하게 만들지만, 빌드 시간 자체는 줄일 수 있다.
  
4. 컴파일 시간 단축:
- 의존성 제거를 통해 특정 클래스에 대한 변경 사항이 다른 클래스의 재컴파일을 강제하지 않도록 함으로써, 컴파일 시간을 줄일 수 있다.
- 예를 들어, ConsultantSchedulerDB와 같은 클래스의 인터페이스를 추출하면, 이 인터페이스에 의존하는 클래스들은 그 구현을 변경해도 다시 컴파일할 필요가 없다.
  
5. 더 나은 패키지 구조:
- 코드베이스를 분리된 패키지로 재구성함으로써, 특정 패키지의 변경이 다른 패키지에 영향을 주지 않도록 할 수 있다. 이를 통해 특정 패키지의 코드가 빠르게 컴파일되고 테스트될 수 있다.

6. 의존성 역전 원칙:
- 인터페이스에 의존하게 함으로써, 코드 변경이 기존 시스템에 미치는 영향을 최소화할 수 있다. 인터페이스는 구현보다 변경이 덜 자주 발생하기 때문에, 인터페이스에 의존함으로써 전체적인 재컴파일을 줄일 수 있다.

7. 최적화의 가치:
- 빌드 시간을 최적화하면 개발 중 더 빠른 피드백을 받을 수 있으며, 이는 더 적은 오류와 더 나은 개발 경험으로 이어진다. 비록 더 많은 인터페이스와 패키지를 도입함으로써 구조가 복잡해질 수 있지만, 장기적으로는 효율성을 높이는 데 매우 유용하다.


<img width="491" alt="스크린샷 2024-09-02 오후 2 03 19" src="https://github.com/user-attachments/assets/6cdcf385-71d1-4bac-b5ff-cacc6d26ff3c">
<img width="496" alt="스크린샷 2024-09-02 오후 2 30 12" src="https://github.com/user-attachments/assets/d5e1521c-5919-478f-9e70-194b49a546c1">
<img width="478" alt="스크린샷 2024-09-02 오후 2 30 40" src="https://github.com/user-attachments/assets/2392c429-df2c-40bc-9758-6bf5f8b427f3">
<img width="477" alt="스크린샷 2024-09-02 오후 2 30 51" src="https://github.com/user-attachments/assets/0e9d1110-2579-48b0-bd82-cb60facbe384">
<img width="478" alt="스크린샷 2024-09-02 오후 2 31 04" src="https://github.com/user-attachments/assets/5fa7a7ac-ffc2-434d-b32c-8f6a40cef05f">
